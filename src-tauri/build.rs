use heck::ToUpperCamelCase;
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::Path;

fn main() -> io::Result<()> {
    println!("cargo:rerun-if-changed=src/effects/fx");

    let effects_dir = Path::new("src/effects/fx");
    fs::create_dir_all(effects_dir)?; // Ensure the `fx` directory exists

    let mut effects = Vec::new();
    if let Ok(entries) = fs::read_dir(effects_dir) {
        for entry in entries.filter_map(Result::ok) {
            let path = entry.path();
            if path.is_file() {
                if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                    if file_stem != "mod" {
                        effects.push(file_stem.to_string());
                    }
                }
            }
        }
    }
    effects.sort();

    // --- Generate `effects/fx/mod.rs` ---
    {
        let mut file = File::create("src/effects/fx/mod.rs")?;
        writeln!(file, "// This file is auto-generated by build.rs. Do not edit manually.\n")?;
        for effect in &effects {
            writeln!(file, "pub mod {};", effect)?;
        }
    }

    // --- Generate `effects/mod.rs` ---
    {
        let mut file = File::create("src/effects/mod.rs")?;
        writeln!(file, "// This file is auto-generated by build.rs. Do not edit manually.\n")?;
        writeln!(file, "use crate::audio::AudioAnalysisData;")?;
        writeln!(file, "use serde::{{Deserialize, Serialize}};")?;
        writeln!(file, "use serde_json::Value;")?;
        writeln!(file, "use specta::Type;")?;
        writeln!(file, "pub use crate::effects::schema::{{Control, DefaultValue, EffectSetting}};\n")?;
        
        writeln!(file, "mod fx;")?;
        for effect in &effects {
            writeln!(file, "pub use fx::{};", effect)?;
        }

        writeln!(file, "\npub mod schema;\n")?;
        writeln!(file, "#[derive(Deserialize, Serialize, Type, Clone, Debug)]")?;
        writeln!(file, "#[serde(rename_all = \"snake_case\")]")?;
        writeln!(file, "pub struct BaseEffectConfig {{")?;
        writeln!(file, "    pub mirror: bool,\n    pub flip: bool,\n    pub blur: f32,\n    pub background_color: String,\n}}\n")?;
        writeln!(file, "pub trait Effect: Send + Sync {{")?;
        writeln!(file, "    fn render(&mut self, audio_data: &AudioAnalysisData, frame: &mut [u8]);")?;
        writeln!(file, "    fn update_config(&mut self, config: Value);")?;
        writeln!(file, "    fn get_base_config(&self) -> BaseEffectConfig;\n}}\n")?;
        writeln!(file, "pub fn get_base_schema() -> Vec<EffectSetting> {{")?;
        writeln!(file, "    vec![")?;
        writeln!(file, "        EffectSetting {{ id: \"mirror\".to_string(), name: \"Mirror\".to_string(), description: \"Mirror the effect\".to_string(), control: Control::Checkbox, default_value: DefaultValue::Bool(false) }},")?;
        writeln!(file, "        EffectSetting {{ id: \"flip\".to_string(), name: \"Flip\".to_string(), description: \"Flip the effect direction\".to_string(), control: Control::Checkbox, default_value: DefaultValue::Bool(false) }},")?;
        writeln!(file, "        EffectSetting {{ id: \"blur\".to_string(), name: \"Blur\".to_string(), description: \"Amount to blur the effect\".to_string(), control: Control::Slider {{ min: 0.0, max: 10.0, step: 0.1 }}, default_value: DefaultValue::Number(0.0) }},")?;
        writeln!(file, "        EffectSetting {{ id: \"background_color\".to_string(), name: \"Background Color\".to_string(), description: \"Color of Background\".to_string(), control: Control::ColorPicker, default_value: DefaultValue::String(\"#000000\".to_string()) }},")?;
        writeln!(file, "    ]\n}}")?;
    }

    // --- Generate `engine/generated.rs` ---
    {
        let mut file = File::create("src/engine/generated.rs")?;
        writeln!(file, "// This file is auto-generated by build.rs. Do not edit manually.\n")?;
        writeln!(file, "use crate::effects;")?;
        writeln!(file, "use serde::{{Deserialize, Serialize}};")?;
        writeln!(file, "use specta::Type;")?;
        writeln!(file, "use super::EffectInfo;\n")?;
        
        writeln!(file, "#[derive(Deserialize, Serialize, Type, Clone, Debug)]")?;
        writeln!(file, "#[serde(tag = \"type\", content = \"config\")]")?;
        writeln!(file, "pub enum EffectConfig {{")?;
        for effect in &effects {
            let variant_name = effect.to_upper_camel_case();
            writeln!(file, "    #[serde(rename = \"{}\")]", effect)?;
            writeln!(file, "    {}(effects::{}::{}Config),", variant_name, effect, variant_name)?;
        }
        writeln!(file, "}}\n")?;

        writeln!(file, "#[tauri::command]\n#[specta::specta]")?;
        writeln!(file, "pub fn get_available_effects() -> Result<Vec<EffectInfo>, String> {{")?;
        writeln!(file, "    Ok(vec![")?;
        for effect in &effects {
            writeln!(file, "        EffectInfo {{ id: \"{}\".to_string(), name: effects::{}::NAME.to_string() }},", effect, effect)?;
        }
        writeln!(file, "    ])\n}}\n")?;

        writeln!(file, "#[tauri::command]\n#[specta::specta]")?;
        writeln!(file, "pub fn get_effect_schema(effect_id: String) -> Result<Vec<effects::schema::EffectSetting>, String> {{")?;
        writeln!(file, "    match effect_id.as_str() {{")?;
        for effect in &effects {
            writeln!(file, "        \"{}\" => Ok(effects::{}::get_schema()),", effect, effect)?;
        }
        writeln!(file, "        _ => Err(format!(\"Schema not found for effect: {{}}\", effect_id)),")?;
        writeln!(file, "    }}\n}}\n")?;
        
        writeln!(file, "pub fn create_effect(config: EffectConfig) -> Box<dyn effects::Effect> {{")?;
        writeln!(file, "    match config {{")?;
        for effect in &effects {
            let variant_name = effect.to_upper_camel_case();
            writeln!(file, "        EffectConfig::{}(c) => Box::new(effects::{}::{}::new(c)),", variant_name, effect, variant_name)?;
        }
        writeln!(file, "    }}\n}}")?;
    }
    
    tauri_build::build();
    Ok(())
}