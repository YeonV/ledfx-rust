use heck::ToUpperCamelCase;
use std::fs;
use std::path::Path;

fn main() {
    let effects_dir = Path::new("src/effects");
    let mut effects = Vec::new();

    if let Ok(entries) = fs::read_dir(effects_dir) {
        for entry in entries.filter_map(Result::ok) {
            let path = entry.path();
            if path.is_file() {
                if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                    if file_stem != "mod" && file_stem != "schema" {
                        effects.push(file_stem.to_string());
                    }
                }
            }
        }
    }
    effects.sort();

    // --- Generate `effects/mod.rs` ---
    let mut mod_content = String::from("// This file is auto-generated by build.rs. Do not edit manually.\n\n");
    mod_content.push_str("use crate::audio::AudioAnalysisData;\n");
    mod_content.push_str("use serde::{Deserialize, Serialize};\n");
    mod_content.push_str("use serde_json::Value;\n");
    mod_content.push_str("use specta::Type;\n");
    mod_content.push_str("pub use crate::effects::schema::{Control, DefaultValue, EffectSetting};\n\n");
    for effect in &effects {
        mod_content.push_str(&format!("pub mod {};\n", effect));
    }
    mod_content.push_str("\npub mod schema;\n\n");
    mod_content.push_str("#[derive(Deserialize, Serialize, Type, Clone, Debug)]\n");
    mod_content.push_str("#[serde(rename_all = \"snake_case\")]\n");
    mod_content.push_str("pub struct BaseEffectConfig {\n    pub mirror: bool,\n    pub flip: bool,\n    pub blur: f32,\n    pub background_color: String,\n}\n\n");
    mod_content.push_str("pub trait Effect: Send + Sync {\n");
    mod_content.push_str("    fn render(&mut self, audio_data: &AudioAnalysisData, frame: &mut [u8]);\n");
    mod_content.push_str("    fn update_config(&mut self, config: Value);\n");
    mod_content.push_str("    fn get_base_config(&self) -> BaseEffectConfig;\n}\n\n");
    mod_content.push_str("pub fn get_base_schema() -> Vec<EffectSetting> {\n");
    mod_content.push_str("    vec![\n");
    mod_content.push_str("        EffectSetting { id: \"mirror\".to_string(), name: \"Mirror\".to_string(), description: \"Mirror the effect\".to_string(), control: Control::Checkbox, default_value: DefaultValue::Bool(false) },\n");
    mod_content.push_str("        EffectSetting { id: \"flip\".to_string(), name: \"Flip\".to_string(), description: \"Flip the effect direction\".to_string(), control: Control::Checkbox, default_value: DefaultValue::Bool(false) },\n");
    mod_content.push_str("        EffectSetting { id: \"blur\".to_string(), name: \"Blur\".to_string(), description: \"Amount to blur the effect\".to_string(), control: Control::Slider { min: 0.0, max: 10.0, step: 0.1 }, default_value: DefaultValue::Number(0.0) },\n");
    mod_content.push_str("        EffectSetting { id: \"background_color\".to_string(), name: \"Background Color\".to_string(), description: \"Color of Background\".to_string(), control: Control::ColorPicker, default_value: DefaultValue::String(\"#000000\".to_string()) },\n");
    mod_content.push_str("    ]\n}\n");
    fs::write("src/effects/mod.rs", mod_content).unwrap();

    // --- Generate `engine/generated.rs` ---
    let mut generated_content = String::from("// This file is auto-generated by build.rs. Do not edit manually.\n\n");
    generated_content.push_str("use crate::effects;\n");
    generated_content.push_str("use serde::{Deserialize, Serialize};\n");
    generated_content.push_str("use specta::Type;\n");
    generated_content.push_str("use super::{EffectInfo};\n\n");
    
    generated_content.push_str("#[derive(Deserialize, Serialize, Type, Clone)]\n");
    generated_content.push_str("#[serde(tag = \"type\", content = \"config\")]\n");
    generated_content.push_str("pub enum EffectConfig {\n");
    for effect in &effects {
        let variant_name = effect.to_upper_camel_case();
        generated_content.push_str(&format!("    #[serde(rename = \"{}\")]\n", effect));
        generated_content.push_str(&format!("    {}(effects::{}::{}Config),\n", variant_name, effect, variant_name));
    }
    generated_content.push_str("}\n\n");

    generated_content.push_str("#[tauri::command]\n#[specta::specta]\n");
    generated_content.push_str("pub fn get_available_effects() -> Result<Vec<EffectInfo>, String> {\n");
    generated_content.push_str("    Ok(vec![\n");
    for effect in &effects {
        let variant_name = effect.to_upper_camel_case();
        generated_content.push_str(&format!("        EffectInfo {{ id: \"{}\".to_string(), name: effects::{}::NAME.to_string(), variant: \"{}\".to_string() }},\n", effect, effect, variant_name));
    }
    generated_content.push_str("    ])\n}\n\n");

    generated_content.push_str("#[tauri::command]\n#[specta::specta]\n");
    generated_content.push_str("pub fn get_effect_schema(effect_id: String) -> Result<Vec<effects::schema::EffectSetting>, String> {\n");
    generated_content.push_str("    match effect_id.as_str() {\n");
    for effect in &effects {
        generated_content.push_str(&format!("        \"{}\" => Ok(effects::{}::get_schema()),\n", effect, effect));
    }
    generated_content.push_str("        _ => Err(format!(\"Schema not found for effect: {}\", effect_id)),\n");
    generated_content.push_str("    }\n}\n\n");
    
    generated_content.push_str("pub fn create_effect(config: EffectConfig) -> Box<dyn effects::Effect> {\n");
    generated_content.push_str("    match config {\n");
    for effect in &effects {
        let variant_name = effect.to_upper_camel_case();
        generated_content.push_str(&format!("        EffectConfig::{}(c) => Box::new(effects::{}::{}::new(c)),\n", variant_name, effect, variant_name));
    }
    generated_content.push_str("    }\n}\n");
    
    fs::write("src/engine/generated.rs", generated_content).unwrap();
    
    tauri_build::build();
}