// This file is auto-generated by generate-effects.js. Do not edit manually.

use super::EffectInfo;
use crate::effects;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use specta::Type;

#[derive(Deserialize, Serialize, Type, Clone, Debug)]
#[serde(tag = "type", content = "config")]
pub enum EffectConfig {
    #[serde(rename = "blade_power")]
    BladePower(effects::blade_power::BladePowerConfig),
    #[serde(rename = "fire")]
    Fire(effects::fire::FireConfig),
    #[serde(rename = "scan")]
    Scan(effects::scan::ScanConfig),
}

#[tauri::command]
#[specta::specta]
pub fn get_available_effects() -> Result<Vec<EffectInfo>, String> {
    Ok(vec![
        EffectInfo {
            id: "blade_power".to_string(),
            name: effects::blade_power::NAME.to_string(),
        },
        EffectInfo {
            id: "fire".to_string(),
            name: effects::fire::NAME.to_string(),
        },
        EffectInfo {
            id: "scan".to_string(),
            name: effects::scan::NAME.to_string(),
        },
    ])
}

#[tauri::command]
#[specta::specta]
pub fn get_effect_schema(effect_id: String) -> Result<Vec<effects::schema::EffectSetting>, String> {
    match effect_id.as_str() {
        "blade_power" => Ok(effects::blade_power::get_schema()),
        "fire" => Ok(effects::fire::get_schema()),
        "scan" => Ok(effects::scan::get_schema()),
        _ => Err(format!("Schema not found for effect: {}", effect_id)),
    }
}

pub fn create_effect(config: EffectConfig) -> Box<dyn effects::Effect> {
    match config {
        EffectConfig::BladePower(c) => Box::new(effects::blade_power::BladePower::new(c)),
        EffectConfig::Fire(c) => Box::new(effects::fire::Fire::new(c)),
        EffectConfig::Scan(c) => Box::new(effects::scan::Scan::new(c)),
    }
}

pub fn config_to_value(config: EffectConfig) -> Value {
    match config {
        EffectConfig::BladePower(c) => serde_json::to_value(c).unwrap(),
        EffectConfig::Fire(c) => serde_json::to_value(c).unwrap(),
        EffectConfig::Scan(c) => serde_json::to_value(c).unwrap(),
    }
}

use std::collections::HashMap;

pub fn get_effect_id_from_config(config: &EffectConfig) -> String {
    match config {
        EffectConfig::BladePower(_) => "blade_power".to_string(),
        EffectConfig::Fire(_) => "fire".to_string(),
        EffectConfig::Scan(_) => "scan".to_string(),
    }
}

pub fn get_built_in_presets_for_effect(effect_id: &str) -> HashMap<String, EffectConfig> {
    match effect_id {
        "blade_power" => effects::blade_power::get_built_in_presets(),
        "fire" => effects::fire::get_built_in_presets(),
        "scan" => effects::scan::get_built_in_presets(),
        _ => HashMap::new(),
    }
}
