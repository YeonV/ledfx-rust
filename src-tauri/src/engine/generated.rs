// This file is auto-generated by generate-effects.js. Do not edit manually.

use crate::effects;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use specta::Type;
use super::EffectInfo;

#[derive(Deserialize, Serialize, Type, Clone, Debug)]
#[serde(tag = "type", content = "config")]
pub enum EffectConfig {
    #[serde(rename = "blade_power")]
    BladePower(effects::blade_power::BladePowerConfig),
    #[serde(rename = "fire")]
    Fire(effects::fire::FireConfig),
    #[serde(rename = "scan")]
    Scan(effects::scan::ScanConfig),
}

#[tauri::command]
#[specta::specta]
pub fn get_available_effects() -> Result<Vec<EffectInfo>, String> {
    Ok(vec![
        EffectInfo { id: "blade_power".to_string(), name: effects::blade_power::NAME.to_string() },
        EffectInfo { id: "fire".to_string(), name: effects::fire::NAME.to_string() },
        EffectInfo { id: "scan".to_string(), name: effects::scan::NAME.to_string() },
    ])
}

#[tauri::command]
#[specta::specta]
pub fn get_effect_schema(effect_id: String) -> Result<Vec<effects::schema::EffectSetting>, String> {
    match effect_id.as_str() {
        "blade_power" => Ok(effects::blade_power::get_schema()),
        "fire" => Ok(effects::fire::get_schema()),
        "scan" => Ok(effects::scan::get_schema()),
        _ => Err(format!("Schema not found for effect: {}", effect_id)),
    }
}

pub fn create_effect(config: EffectConfig) -> Box<dyn effects::Effect> {
    match config {
        EffectConfig::BladePower(c) => Box::new(effects::blade_power::BladePower::new(c)),
        EffectConfig::Fire(c) => Box::new(effects::fire::Fire::new(c)),
        EffectConfig::Scan(c) => Box::new(effects::scan::Scan::new(c)),
    }
}

pub fn config_to_value(config: EffectConfig) -> Value {
    match config {
        EffectConfig::BladePower(c) => serde_json::to_value(c).unwrap(),
        EffectConfig::Fire(c) => serde_json::to_value(c).unwrap(),
        EffectConfig::Scan(c) => serde_json::to_value(c).unwrap(),
    }
}
