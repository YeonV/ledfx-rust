import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';

const EFFECTS_DIR = path.join('src-tauri', 'src', 'effects');
const FX_DIR = path.join(EFFECTS_DIR, 'fx');
const MOD_FILE = path.join(EFFECTS_DIR, 'mod.rs');
const GENERATED_FILE = path.join('src-tauri', 'src', 'engine', 'generated.rs');
const CACHE_FILE = path.join('scripts', '.generation-cache.json');

// --- Hashing Logic ---
async function getFileHash(filePath) {
    try {
        const fileBuffer = await fs.readFile(filePath);
        return crypto.createHash('sha256').update(fileBuffer).digest('hex');
    } catch (error) {
        if (error.code === 'ENOENT') return null; // File doesn't exist
        throw error;
    }
}

async function readCache() {
    try {
        const content = await fs.readFile(CACHE_FILE, 'utf-8');
        return JSON.parse(content);
    } catch (error) {
        return {};
    }
}

async function writeCache(cache) {
    await fs.writeFile(CACHE_FILE, JSON.stringify(cache, null, 2));
}

// --- Code Generation Logic ---
function generateModFileContent(effects) {
    const mods = effects.map(name => `#[path = "fx/${name}.rs"]\npub mod ${name};`).join('\n');
    return `// This file is auto-generated by generate-effects.js. Do not edit manually.

use crate::audio::AudioAnalysisData;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use specta::Type;
pub use crate::effects::schema::{Control, DefaultValue, EffectSetting};

${mods}

pub mod schema;

#[derive(Deserialize, Serialize, Type, Clone, Debug)]
#[serde(rename_all = "snake_case")]
pub struct BaseEffectConfig {
    pub mirror: bool,
    pub flip: bool,
    pub blur: f32,
    pub background_color: String,
}

pub trait Effect: Send + Sync {
    fn render(&mut self, audio_data: &AudioAnalysisData, frame: &mut [u8]);
    fn update_config(&mut self, config: Value);
    fn get_base_config(&self) -> BaseEffectConfig;
}

pub fn get_base_schema() -> Vec<EffectSetting> {
    vec![
        EffectSetting { id: "mirror".to_string(), name: "Mirror".to_string(), description: "Mirror the effect".to_string(), control: Control::Checkbox, default_value: DefaultValue::Bool(false) },
        EffectSetting { id: "flip".to_string(), name: "Flip".to_string(), description: "Flip the effect direction".to_string(), control: Control::Checkbox, default_value: DefaultValue::Bool(false) },
        EffectSetting { id: "blur".to_string(), name: "Blur".to_string(), description: "Amount to blur the effect".to_string(), control: Control::Slider { min: 0.0, max: 10.0, step: 0.1 }, default_value: DefaultValue::Number(0.0) },
        EffectSetting { id: "background_color".to_string(), name: "Background Color".to_string(), description: "Color of Background".to_string(), control: Control::ColorPicker, default_value: DefaultValue::String("#000000".to_string()) },
    ]
}
`;
}

function generateEngineFileContent(effects) {
    const toCamelCase = (str) => str.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');

    const effectConfigVariants = effects.map(name => 
        `    #[serde(rename = "${name}")]\n    ${toCamelCase(name)}(effects::${name}::${toCamelCase(name)}Config),`
    ).join('\n');

    const availableEffectsItems = effects.map(name => 
        `        EffectInfo { id: "${name}".to_string(), name: effects::${name}::NAME.to_string() },`
    ).join('\n');

    const effectSchemaArms = effects.map(name => 
        `        "${name}" => Ok(effects::${name}::get_schema()),`
    ).join('\n');

    const createEffectArms = effects.map(name => 
        `        EffectConfig::${toCamelCase(name)}(c) => Box::new(effects::${name}::${toCamelCase(name)}::new(c)),`
    ).join('\n');
    
    const configToValueArms = effects.map(name =>
        `        EffectConfig::${toCamelCase(name)}(c) => serde_json::to_value(c).unwrap(),`
    ).join('\n');

    return `// This file is auto-generated by generate-effects.js. Do not edit manually.

use crate::effects;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use specta::Type;
use super::EffectInfo;

#[derive(Deserialize, Serialize, Type, Clone, Debug)]
#[serde(tag = "type", content = "config")]
pub enum EffectConfig {
${effectConfigVariants}
}

#[tauri::command]
#[specta::specta]
pub fn get_available_effects() -> Result<Vec<EffectInfo>, String> {
    Ok(vec![
${availableEffectsItems}
    ])
}

#[tauri::command]
#[specta::specta]
pub fn get_effect_schema(effect_id: String) -> Result<Vec<effects::schema::EffectSetting>, String> {
    match effect_id.as_str() {
${effectSchemaArms}
        _ => Err(format!("Schema not found for effect: {}", effect_id)),
    }
}

pub fn create_effect(config: EffectConfig) -> Box<dyn effects::Effect> {
    match config {
${createEffectArms}
    }
}

pub fn config_to_value(config: EffectConfig) -> Value {
    match config {
${configToValueArms}
    }
}
`;
}

// --- Main Logic ---
async function runGeneration() {
    console.log('[FX-GEN] Checking for effect changes...');
    
    let currentHashes = {};
    let effects = [];

    try {
        const entries = await fs.readdir(FX_DIR, { withFileTypes: true });
        for (const entry of entries) {
            if (entry.isFile() && entry.name.endsWith('.rs') && entry.name !== 'mod.rs') {
                const filePath = path.join(FX_DIR, entry.name);
                const fileStem = path.parse(entry.name).name;
                effects.push(fileStem);
                currentHashes[filePath] = await getFileHash(filePath);
            }
        }
        effects.sort();

        const cachedHashes = await readCache();

        if (JSON.stringify(currentHashes) === JSON.stringify(cachedHashes)) {
            console.log('[FX-GEN] No changes detected. Skipping generation.');
            return;
        }

        console.log('[FX-GEN] Changes detected. Regenerating files...');
        
        const modContent = generateModFileContent(effects);
        await fs.writeFile(MOD_FILE, modContent);
        
        const engineContent = generateEngineFileContent(effects);
        await fs.writeFile(GENERATED_FILE, engineContent);

        await writeCache(currentHashes);
        console.log('[FX-GEN] Generation complete.');

    } catch (error) {
        if (error.code === 'ENOENT') {
            console.log(`[FX-GEN] '${FX_DIR}' not found, skipping generation.`);
        } else {
            console.error('[FX-GEN] Error during generation:', error);
        }
    }
}

// --- Watcher Logic ---
(async () => {
    // Run once on startup
    await runGeneration();

    console.log(`[FX-GEN] Watching for changes in '${FX_DIR}'...`);
    // The `--watch` flag in the package.json script handles the watching.
    // This script will be re-run by Node.js on any file change.
})();